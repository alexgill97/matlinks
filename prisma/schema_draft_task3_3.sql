-- Subtask 3.3: Classes and Attendance Schema

-- Class Types Table (Defining the kinds of classes offered)
CREATE TABLE class_types (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  gym_id BIGINT NOT NULL REFERENCES gyms(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT,
  difficulty_level TEXT, -- e.g., 'Beginner', 'Advanced', 'All Levels'
  default_duration INT, -- Default duration in minutes
  prerequisites TEXT,
  created_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Class Schedules Table (Recurring schedules)
CREATE TABLE class_schedules (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  location_id BIGINT NOT NULL REFERENCES locations(id) ON DELETE CASCADE,
  class_type_id BIGINT NOT NULL REFERENCES class_types(id) ON DELETE CASCADE,
  instructor_id UUID REFERENCES profiles(id) ON DELETE SET NULL, -- Instructor assigned to this recurring schedule
  start_time TIME NOT NULL,
  end_time TIME NOT NULL,
  -- Using integers for days of the week (0=Sunday, 1=Monday, ..., 6=Saturday) for flexibility
  -- Could also use ENUM or individual boolean columns
  days_of_week INT[] NOT NULL CHECK (array_length(days_of_week, 1) > 0 AND days_of_week::int[] <@ ARRAY[0,1,2,3,4,5,6]::int[]),
  start_date DATE NOT NULL DEFAULT CURRENT_DATE,
  end_date DATE, -- Nullable for ongoing schedules
  capacity INT,
  requires_booking BOOLEAN DEFAULT false NOT NULL,
  created_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Class Instances Table (Specific occurrences generated from schedules)
CREATE TABLE class_instances (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  schedule_id BIGINT REFERENCES class_schedules(id) ON DELETE SET NULL, -- Link to recurring schedule if applicable
  location_id BIGINT NOT NULL REFERENCES locations(id) ON DELETE CASCADE,
  class_type_id BIGINT NOT NULL REFERENCES class_types(id) ON DELETE CASCADE,
  instructor_id UUID REFERENCES profiles(id) ON DELETE SET NULL,
  instance_timestamp TIMESTAMPTZ NOT NULL, -- Specific date and time of the class
  duration_minutes INT NOT NULL,
  capacity INT,
  requires_booking BOOLEAN NOT NULL,
  status TEXT DEFAULT 'scheduled' NOT NULL CHECK (status IN ('scheduled', 'completed', 'cancelled')), -- Or use ENUM type
  notes TEXT, -- For specific instance notes, e.g., substitute instructor
  created_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Attendance Records Table
CREATE TABLE attendance_records (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  class_instance_id BIGINT NOT NULL REFERENCES class_instances(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  check_in_time TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL,
  check_in_method TEXT, -- e.g., 'admin', 'kiosk', 'manual'
  notes TEXT,

  -- Prevent duplicate check-ins for the same user in the same class instance
  UNIQUE (class_instance_id, user_id)
);

-- Indexes
CREATE INDEX idx_class_schedules_location_id ON class_schedules(location_id);
CREATE INDEX idx_class_instances_timestamp ON class_instances(instance_timestamp);
CREATE INDEX idx_class_instances_location_id ON class_instances(location_id);
CREATE INDEX idx_class_instances_instructor_id ON class_instances(instructor_id);
CREATE INDEX idx_attendance_records_instance_id ON attendance_records(class_instance_id);
CREATE INDEX idx_attendance_records_user_id ON attendance_records(user_id);

-- Helper function to check if a user is an admin or owner of a specific gym
-- Assumes profiles table has user roles and locations table links to gyms
CREATE OR REPLACE FUNCTION is_gym_admin_or_owner(user_id_input UUID, gym_id_input BIGINT)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  user_role TEXT;
BEGIN
  SELECT role INTO user_role FROM public.profiles WHERE id = user_id_input;
  IF user_role IN ('admin', 'owner') THEN
    -- Check if the user is associated with the specific gym indirectly (e.g., through location or direct gym link if added later)
    -- This is a placeholder logic, might need refinement based on exact relationships
    -- For now, assume admin/owner can manage all gyms, refine if multi-gym admin roles differ
    RETURN TRUE;
  END IF;
  RETURN FALSE;
END;
$$;

-- RLS Policies

-- Enable RLS for new tables
ALTER TABLE class_types ENABLE ROW LEVEL SECURITY;
ALTER TABLE class_schedules ENABLE ROW LEVEL SECURITY;
ALTER TABLE class_instances ENABLE ROW LEVEL SECURITY;
ALTER TABLE attendance_records ENABLE ROW LEVEL SECURITY;

-- Class Types Policies
-- Authenticated users can view class types belonging to any gym (adjust if needed)
CREATE POLICY "Authenticated users can view class types" ON class_types
  FOR SELECT TO authenticated USING (true);
-- TODO: Add policy for admins/owners to manage class types for their gym

-- Class Schedules Policies
-- Authenticated users can view schedules
CREATE POLICY "Authenticated users can view schedules" ON class_schedules
  FOR SELECT TO authenticated USING (true);
-- TODO: Add policy for admins/owners/instructors to manage schedules

-- Class Instances Policies
-- Authenticated users can view instances
CREATE POLICY "Authenticated users can view class instances" ON class_instances
  FOR SELECT TO authenticated USING (true);
-- Instructors can manage instances they are assigned to
CREATE POLICY "Instructors can manage their assigned class instances" ON class_instances
  FOR ALL -- Allows SELECT, INSERT, UPDATE, DELETE
  USING (auth.uid() = instructor_id)
  WITH CHECK (auth.uid() = instructor_id);
-- TODO: Add policy for admins/owners to manage all instances for their gym

-- Attendance Records Policies
-- Users can view their own attendance records
CREATE POLICY "Users can view their own attendance records" ON attendance_records
  FOR SELECT USING (auth.uid() = user_id);
-- Instructors can view attendance for class instances they are assigned to
CREATE POLICY "Instructors can view attendance for their classes" ON attendance_records
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1
      FROM class_instances ci
      WHERE ci.id = attendance_records.class_instance_id AND ci.instructor_id = auth.uid()
    )
  );
-- Instructors can INSERT attendance for class instances they are assigned to
CREATE POLICY "Instructors can insert attendance for their classes" ON attendance_records
  FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1
      FROM class_instances ci
      WHERE ci.id = attendance_records.class_instance_id AND ci.instructor_id = auth.uid()
    )
  );
-- Instructors can DELETE attendance for class instances they are assigned to
CREATE POLICY "Instructors can delete attendance for their classes" ON attendance_records
  FOR DELETE
  USING (
    EXISTS (
      SELECT 1
      FROM class_instances ci
      WHERE ci.id = attendance_records.class_instance_id AND ci.instructor_id = auth.uid()
    )
  );
-- TODO: Add policy for admins/owners to manage all attendance for their gym 